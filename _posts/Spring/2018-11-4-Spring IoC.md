---
tags: [Spring]
---
## <center>Spring IoC[转]</center>

##### 1.依赖倒置

​	假设我们设计一辆汽车：先设计<u>轮子</u>，然后根据轮子大小设计<u>底盘</u>，接着根据底盘设计<u>车身</u>，最后根据车身设计好整个<u>汽车</u>。这里就出现了一个“依赖”关系：汽车依赖车身，车身依赖底盘，底盘依赖轮子。

​	这种常规设计面临的挑战：这样的设计看起来没问题，但是可维护性却很低。

​	假设设计完工之后，上司却突然说根据市场需求的变动，要我们把车子的轮子设计都改大一码。这下我们就蛋疼了：因为我们是根据轮子的尺寸设计的底盘，轮子的尺寸一改，底盘的设计就得修改；同样因为我们是根据底盘设计的车身，那么车身也得改，同理汽车设计也得改——整个设计几乎都得改！	

​	现在换一种思路。我们先设计汽车的大概样子，然后根据汽车的样子来设计车身，根据车身来设计底盘，最后根据底盘来设计轮子。这时候，依赖关系就倒置过来了：轮子依赖底盘， 底盘依赖车身， 车身依赖汽车。 ——**依赖倒置**

​	依赖倒置的优势：不会出现前面的“牵一发动全身”的情况

​	这时候，上司再说要改动轮子的设计，我们就只需要改动轮子的设计，而不需要动底盘，车身，汽车的设计了。这就是依赖倒置原则——把原本的高层建筑依赖底层建筑“倒置”过来，变成底层建筑依赖高层建筑。**高层建筑决定需要什么，底层去实现这样的需求，但是高层并不用管底层是怎么实现的**。这样就不会出现前面的“牵一发动全身”的情况。 

##### 2.控制反转

控制反转就是依赖倒置原则的一种代码设计的思路 ，具体采用的方法就是所谓的依赖注入

##### 总结：依赖倒置 VS 控制反转IoC VS 依赖注入

![](https://fenglinliu.github.io/assets/img/blog/2019-02-18_152618.png)

为了理解这几个概念，我们还是用上面汽车的例子。只不过这次换成代码。我们先定义四个Class，车，车身，底盘，轮胎。然后初始化这辆车，最后跑这辆车。代码结构如下： 

![](https://fenglinliu.github.io/assets/img/blog/640.jpg)

这样，就相当于上面第一个例子，上层建筑依赖下层建筑——每一个类的构造函数都直接调用了底层代码的构造函数。假设我们需要改动一下轮胎（Tire）类，把它的尺寸变成动态的，而不是一直都是30。我们需要这样改： 

![](https://fenglinliu.github.io/assets/img/blog/6401.jpg)

由于我们修改了轮胎的定义，为了让整个程序正常运行，我们需要做以下改动：【**可以看到，<u>尺寸参数从上往下传递</u>，底层是代码的根基，控制着上层**】 

![](https://fenglinliu.github.io/assets/img/blog/6402.jpg)

由此我们可以看到，仅仅是为了修改轮胎的构造函数，<u>这种设计却需要修改整个上层所有类的构造函数</u>，那软件的维护成本就太高了 ！ **所以我们需要进行控制反转（IoC）** ：就是上层控制下层（而不是下层控制着上层 ）。

##### 3.依赖注入

##### **依赖注入（Dependency Injection）可以实现控制反转（IoC）**。 

这里我们用*构造方法传递*的依赖注入方式｛其实还有另外两种方法：*Setter传递*和*接口传递*。@Autowired是反射注入 ｝重新写车类的定义： 【**可以看到，<u>尺寸参数从下往上传递，并且传递的过程中参数类型在不断变化</u>，上层变成了代码的根基，控制反转了**】

![](https://fenglinliu.github.io/assets/img/blog/6403.jpg)

![](https://fenglinliu.github.io/assets/img/blog/6405.jpg)

这里我们再把轮胎尺寸变成动态的，同样为了让整个系统顺利运行，我们需要做如下修改： 

![](https://fenglinliu.github.io/assets/img/blog/6404.jpg)

这里我只需要修改轮胎类就行了，不用修改其他任何上层类。这显然是更容易维护的代码。 

##### 4.控制反转容器(IoC Container)

![](https://fenglinliu.github.io/assets/img/blog/6406.jpg)

因为采用了依赖注入，<u>在初始化的过程中就不可避免的会写大量的new。这里IoC容器就解决了这个问题。</u>这个容器可以自动对你的代码进行初始化，你只需要维护一个Configuration（可以是xml可以是一段代码），而不用每次初始化一辆车都要亲手去写那一大段初始化的代码。这是引入IoC Container的第一个好处。IoC  Container的第二个好处是：我们在创建实例的时候不需要了解其中的细节。在上面的例子中，我们自己手动创建一个车instance时候，是从底层往上层new的： 

![](https://fenglinliu.github.io/assets/img/blog/6407.jpg)

这个过程中，我们需要了解整个Car/Framework/Bottom/Tire类构造函数是怎么定义的，才能一步一步new/注入。而IoC  Container在进行这个工作的时候是反过来的，它先从最上层开始往下找依赖关系，到达最底层之后再往上一步一步new（有点像深度优先遍历）： 

![](https://fenglinliu.github.io/assets/img/blog/6408.jpg)

## <center>xxxxxxx(二号标题)</center>

#### xxxxxx(四号标题)

#####(五号标题)



github图床 https://fenglinliu.github.io/assets/img/blog/640.jpg

